# ctfcup-2022 | Stage2 | ХлебZаVод

Разбор сервиса ХлебZаVод с полуфинала Кубка CTF России 2022.

## Описание

Сервис представляет собой систему из нескольких микросервисов: авторизации, заказов хлеба и выдачи заказов.
Пользователь может зарегистрироваться на основном сайте, оформить заказ на конкретного получателя, а дальше по талончику забрать оформленный заказ из сервиса-магазина.
Для авторизации пользователей и талончиков заказов используется отдельный сервис, подписывающий и валидирующий подписанные токены.

Архитектурно система состоит из 2х сервисов на языке V, у которых есть доступ к PosgreSQL базе данных, сервиса авторизации на языке Zig и сервиса-прокси на Go, необходимого
для регулирования потока запросов на сервисы на V, без чего они не работают (возникает data race в модуле `net` стандартной библиотеки языка V).

## Флаги

Флаги кладутся проверяющей системой в поле "получателя" заказа.

## Уязвимости

Сервис содержит одну уязвимость.

### 1. Подделка подписанного токена.

В сервисе `tokenz` нет задуманных уязвимостей, все пришедшие токены валидируются действительно без ошибок. Проблемы возникают в формате самих запросов на валидацию токенов (эндпоинт `/unsign/:token`) — сервисы `zаvод` и `магаz` делают запросы на валидацию токенов на этот эндпоинт с помощью стандартного `net/http` клиента V, который по дефолту поддерживает редиректы (поддержку редиректов сервисом `tokenz` можно найти, сделав `diff` используемой http библиотеки, apple_pie, с [оригинальной](https://github.com/Luukdegram/apple_pie)).  

Благодаря этому, можно послать сессионную куку в сервис `zаvод` в виде `base64./../session`, за счёт чего сессия будет провалидирована сервисом `tokenz` успешно, после чего в качестве зашифрованных данных возьмётся кусок байт, указанный до сессии (строка 32 модуля [auth](../../services/%D1%85%D0%BB%D0%B5%D0%B1z%D0%B0v%D0%BE%D0%B4/apiz/auth/auth.v#L32)). К сожалению, ключ шифрования достать из сессионного токена мы не можем, так как он зашифрован и подписан сервисом `tokenz`. Несмотря на это, мы можем пытаться посылать различные куски байт, которые сервис будет расшифровывать с помощью потока rc4, полученного с ключом из сессионного токена. Расшифрованные байты будут передаваться в `json.decode` для загрузки сессии, который вернёт ошибку в функцию [before_request](../../services/%D1%85%D0%BB%D0%B5%D0%B1z%D0%B0v%D0%BE%D0%B4/apiz/z%D0%B0v%D0%BE%D0%B4/session.v). Она, в свою очередь, вызовет `app.error`, которая выставит поле `error` в контексте запроса. Далее ошибка может быть выведена на экран, например на страничке `/login`, и может содержать сами расшифрованные данные (если получить невалидный JSON), что и поможет нам достать необходимое кол-во байт из потока rc4 и подписать любые необходимые нам данные.  

Небольшие проблемы возникают ещё с тем, что не всегда выводятся расшифрованные байты, и дополнительно к этому они после какого-то момента обрезаются. Первую проблему можно обойти, посылая всегда зашифрованные данные вида `{aaaaX` где вместо X подставляем новый случайный байт, чтобы угадать следующий символ в расшифрованном потоке, а вторую, посылая префикс из множества символов переноса строки, которые `json.decode` проигнорирует и не выведет в ошибке.  

[Пример скрипта для эксплуатации уязвимости](./token-forgery.py).

#### Исправление уязвимости

Как вариант, можно просто поменять `app.error` на `app.internal_error` в обработке ошибок при валидации сессий в [zаvод/session.v](../../services/%D1%85%D0%BB%D0%B5%D0%B1z%D0%B0v%D0%BE%D0%B4/apiz/z%D0%B0v%D0%BE%D0%B4/session.v#L38), тем самым закрыв вывод нестандартной ошибки пользователю

[Патч для исправления уязвимости](./token-forgery.patch)